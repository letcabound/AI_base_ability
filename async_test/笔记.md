# 异步编程
并不能提高计算速度，目的是提供吞吐量。
最终的效果是提高了CPU利用率，降低了程序在执行 time.sleep()，网络/磁盘 IO 时的CPU等待时长。

## 1. 核心概念：协程(coroutine)、await、事件循环（Event Loop）、Task（协程的“运行态”）
协程(coroutine)
    和普通函数相比，async def 定义的协程函数不是立即执行。调用普通函数，函数会立即执行。调用协程函数，会返回一个协程对象。
    协程真正在执行的时候是在 await 的时候。

await
    让出cpu执行权的"开关"。只能等待一个awaitable对象，例如：另一个协程，或者 异步IO（sleep / 网络 / DB / 文件等）。
    await 协程 ≈ 启动协程 + 等待 + 取结果
    create_task ≈ 启动(交给事件循环)，不管后面是否等待

事件循环(Event Loop)
    维护一堆"未完成的协程"的执行与等待。

Task(协程的运行态)
    协程的生命周期：async def定义 -> 创建协程对象 -> 调度阶段，被事件循环接管 -> 等待 or 不等待 -> 挂起恢复(当前协程让出执行权，事件循环将该Task标记为就绪，并切换到其它任务)
    调度阶段，事件被循环接管 会发生：
        当前主协程暂停，如果是 await 协程b(), 则 创建协程b对象，注册到事件循环并被调度(Task)，协程b运行，如果遇到await重复上述，挂起当前协程，等待返回结果。主协程恢复运行。
        当前主协程暂停，如果是 create_task(协程b())，则将协程b创建并注册到事件循环列表并允许立即调度，此时并没有阻塞主协程。如果主协程没有await或者运行结束了，协程b的返回结果是拿不到的。
    总之，主协程如果只是调度了异步协程b，本身并没有await，主协程是不会被协程b阻塞的。

Q1:不管是主协程还是副协程，只要协程函数开始执行并遇到了阻塞代码，那么所有协程都会被卡住。
A1:asyncio是单线程，事件循环一次只能执行一个协程并且协程只有在await时才会让出执行权且其它协程不会抢占资源，如果协程一直霸占事件循环，所有其它协程都无法被调度。
即：asyncio 是通过 单线程、协作式调度模型 来提高吞吐率；任何不 await 的阻塞代码，都会独占事件循环，导致所有协程被阻塞。

QA2:事件循环的生命周期 = 主协程（main）执行期间，一旦主协程执行完毕，则loop结束，所有未完成的协程/Task都会被强制取消或结束。

QA3: 异步有效挂起 vs 阻塞：异步有效挂起，当前协程虽然停止执行在等待但放开资源占用，事件循环调度器的其它任务可以继续运行。阻塞，当前协程停止执行等待结果且占据资源，事件循环调度器的其它任务无法运行。

QA3: 执行结果分析
```
async def foo():
    print("1 start")
    await asyncio.sleep(1)
    print("2 resume")
    return "done"

async def main():
    print("A")
    task = asyncio.create_task(foo()) # foo()对象注册到事件循环器，返回task对象，但是并没有让出 cpu控制权
    print("B")
    result = await task
    print("C", result)

asyncio.run(main())
```
唯一结果：
A
B 【子协程创建后，添加到循环队列允许立即执行并返回task。但此时主协程并没有让出cpu控制权，所以主协程继续执行。】
1 start
2 resume
C done

## 3. asyncio 事件循环


## 4. 







